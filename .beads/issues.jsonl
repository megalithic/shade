{"id":"shade-141","title":"Shade: Rename MegaNote and implement persistent terminal wrapper","description":"Transform MegaNote into Shade - a lightweight, persistent floating terminal wrapper around libghostty.\n\n## Goals\n- Rename project from MegaNote to Shade (\"lighter than a ghost\")\n- Implement background-on-exit behavior (nvim :wq hides, doesn't quit)\n- Add emergency escape hotkey (independent of Hammerspoon)\n- Support note workflows: quick capture and daily note via IPC\n- Use XDG directories for state files\n- New IPC namespace: io.shade.*\n\n## Non-Goals (Future Phases)\n- Full global hotkey registration (Phase 2)\n- Context gathering in Shade (Phase 2)  \n- Vision/OCR integration (Phase 3)\n- Migrate daily note logic to obsidian.nvim (Phase 3)\n\n## Architecture\n```\n~/.local/state/shade/\n├── context.json    # Capture context from Hammerspoon\n├── nvim.sock       # Nvim RPC socket\n└── shade.pid       # Process management\n\nIPC: io.shade.{toggle,show,hide,quit}\n     io.shade.note.{capture,daily}\n```","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-07T09:02:22.219108-05:00","created_by":"seth","updated_at":"2026-01-07T09:02:22.219108-05:00"}
{"id":"shade-141.1","title":"Rename project: MegaNote → Shade","description":"Comprehensive rename of all project artifacts.\n\n## Changes Required\n- [ ] Rename `Sources/*.swift` types: MegaAppDelegate → ShadeAppDelegate, MegaPanel → ShadePanel\n- [ ] Update Package.swift product name\n- [ ] Update binary name in justfile\n- [ ] Update README.md\n- [ ] Update LICENSE if needed\n- [ ] Update flake.nix package name\n- [ ] Update all IPC notification names: com.meganote.* → io.shade.*\n- [ ] Update Log messages\n- [ ] Update CLI help text and app description\n\n## Verification\n- `just build` succeeds\n- `just run --help` shows 'shade' branding\n- IPC notifications use new namespace","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T09:02:28.85084-05:00","created_by":"seth","updated_at":"2026-01-07T09:21:03.320158-05:00","closed_at":"2026-01-07T09:21:03.320158-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-141.1","depends_on_id":"shade-141","type":"parent-child","created_at":"2026-01-07T09:02:28.851482-05:00","created_by":"seth"}]}
{"id":"shade-141.10","title":"[Future] Phase 2: Move global hotkeys to Shade","description":"Register Hyper+Shift+N and Hyper+Shift+O directly in Shade.\n\n## Goal\nMake Shade fully independent of Hammerspoon for note workflows.\n\n## Scope\n- Register global hotkeys via CGEvent tap\n- Hyper+Shift+N → quick capture (with context gathering)\n- Hyper+Shift+O → daily note\n- Gather context directly in Shade (port get-selection Swift logic)\n\n## Prerequisites\n- shade-141.6 (emergency hotkey) proves CGEvent approach works\n- Accessibility permissions documented\n\n## Considerations\n- Conflicts with Hammerspoon if both register same keys\n- May need config to disable Shade hotkeys if user prefers Hammerspoon\n- Hyper key detection (Cmd+Ctrl+Alt+Shift) in CGEvent\n\n## Defer Until\n- Phase 1 complete and stable\n- User confirms desire to move away from Hammerspoon","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T09:03:20.985527-05:00","created_by":"seth","updated_at":"2026-01-07T09:03:20.985527-05:00","dependencies":[{"issue_id":"shade-141.10","depends_on_id":"shade-141","type":"parent-child","created_at":"2026-01-07T09:03:20.986147-05:00","created_by":"seth"}]}
{"id":"shade-141.11","title":"[Future] Phase 2: Context gathering in Shade","description":"Port context gathering from Hammerspoon to Shade.\n\n## Current State\n- get-selection (Swift script) captures selected text via Accessibility API\n- interop/context.lua gathers browser URLs, nvim state, etc.\n- Hammerspoon orchestrates and writes context.json\n\n## Goal\nShade gathers context itself when quick capture is triggered.\n\n## Implementation\n- Port get-selection logic into Shade\n- Add browser URL detection (JXA or Accessibility)\n- Add nvim context via RPC (already needed for shade-141.8)\n- Write context.json for obsidian.nvim template consumption\n\n## Prerequisites\n- shade-141.8 (nvim RPC) complete\n- Phase 2 hotkeys working\n\n## Considerations\n- Accessibility permissions already required\n- May need entitlements for JXA/AppleScript\n- Some context (like browser URL) may require Hammerspoon's hs.application","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-07T09:03:26.605364-05:00","created_by":"seth","updated_at":"2026-01-08T14:32:33.042786-05:00","closed_at":"2026-01-08T14:32:33.042786-05:00","close_reason":"Implemented via shade-qji epic","dependencies":[{"issue_id":"shade-141.11","depends_on_id":"shade-141","type":"parent-child","created_at":"2026-01-07T09:03:26.605992-05:00","created_by":"seth"},{"issue_id":"shade-141.11","depends_on_id":"shade-qji","type":"parent-child","created_at":"2026-01-08T10:48:24.433866-05:00","created_by":"seth"}]}
{"id":"shade-141.11.1","title":"Context Gathering in Shade (Sub-Epic)","description":"Port context gathering from Hammerspoon to Shade, making Shade self-sufficient for capturing context from the frontmost app.\n\n## Background\nCurrently Hammerspoon orchestrates context gathering via:\n- `bin/get-selection` Swift script (Accessibility API)\n- `lib/interop/context.lua` (app type detection, browser JXA)\n- `lib/interop/nvim.lua` (nvim RPC for buffer info)\n- `lib/interop/shade.lua` (writes context.json)\n\n## Goal\nShade gathers context itself when quick capture is triggered, eliminating Hammerspoon as middleman.\n\n## Architecture\n```\nContextGatherer.swift\n├── AXUIElement → selectedText, windowTitle, bundleID\n├── JXABridge → browser URLs, selections  \n├── NvimAPI (existing!) → buffer info, selection\n└── AppTypeDetector → browser/terminal/editor/other\n```\n\n## Messages.app Note\nUser will use standard copy/paste for selection - no exotic clipboard monitoring needed.","status":"open","priority":3,"issue_type":"epic","created_at":"2026-01-08T10:48:13.541665-05:00","created_by":"seth","updated_at":"2026-01-08T10:48:13.541665-05:00"}
{"id":"shade-141.12","title":"[Future] Phase 3: Vision/OCR integration research","description":"Research and implement image-to-text for captured screenshots.\n\n## Goal\nWhen user captures a screenshot, optionally:\n1. Run OCR to extract text\n2. Run Vision/LLM to summarize content\n3. Include in capture note\n\n## Technologies to Research\n- Apple Vision framework (on-device OCR)\n- Ollama with local models (summarization)\n- VLMs for image understanding\n\n## Integration Points\n- Hammerspoon clipper.lua already handles screenshot capture\n- Could add OCR step before/after upload\n- Shade could coordinate OCR if image path passed in context\n\n## Open Questions\n- Should OCR happen in Hammerspoon, Shade, or separate service?\n- Async processing (don't block capture workflow)?\n- How to inject OCR text into note template?\n\n## Defer Until\n- Phase 2 complete\n- obsidian.nvim templating enhanced","status":"open","priority":4,"issue_type":"task","created_at":"2026-01-07T09:03:32.326018-05:00","created_by":"seth","updated_at":"2026-01-07T09:03:32.326018-05:00","dependencies":[{"issue_id":"shade-141.12","depends_on_id":"shade-141","type":"parent-child","created_at":"2026-01-07T09:03:32.326631-05:00","created_by":"seth"}]}
{"id":"shade-141.13","title":"[Future] Phase 3: Migrate daily note logic to obsidian.nvim","description":"Replace shell script daily_note with obsidian.nvim native functionality.\n\n## Current State\n- daily_note shell script handles:\n  - File creation with template\n  - Task migration from previous day\n  - Tmux session management\n- obsidian.nvim has :ObsidianToday but doesn't migrate tasks\n\n## Goal\nUse obsidian.nvim for all daily note functionality:\n- Template-based creation\n- Custom Lua to migrate tasks from previous day\n- No shell script dependency\n\n## Research Required\n- obsidian.nvim template capabilities\n- Hook into note creation event\n- Access previous day's note programmatically\n- Parse and migrate incomplete tasks\n\n## Implementation Ideas\n- obsidian.nvim callback: on_new_daily_note\n- Custom Lua function to find previous note\n- Treesitter to parse task items\n- Append migrated tasks to new note\n\n## Considerations\n- Task format: - [ ] vs - [x]\n- Which sections to migrate?\n- Handle edge cases (no previous note, weekend gaps)\n\n## Defer Until\n- Phase 2 complete\n- Research obsidian.nvim extensibility","status":"closed","priority":4,"issue_type":"task","created_at":"2026-01-07T09:03:38.533269-05:00","created_by":"seth","updated_at":"2026-01-08T10:32:43.218562-05:00","closed_at":"2026-01-08T10:32:43.218562-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-141.13","depends_on_id":"shade-141","type":"parent-child","created_at":"2026-01-07T09:03:38.534024-05:00","created_by":"seth"}]}
{"id":"shade-141.14","title":"[Future] Native msgpack-rpc client for nvim","description":"Superseded by epic shade-plf - see that epic for detailed breakdown of tasks.","status":"closed","priority":4,"issue_type":"task","created_at":"2026-01-07T09:32:36.276013-05:00","created_by":"seth","updated_at":"2026-01-07T15:52:38.947192-05:00","closed_at":"2026-01-07T15:52:38.947192-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-141.14","depends_on_id":"shade-141","type":"parent-child","created_at":"2026-01-07T09:32:36.278186-05:00","created_by":"seth"}]}
{"id":"shade-141.2","title":"Implement background-on-exit behavior","description":"When the child process (nvim) exits normally, hide the panel instead of terminating Shade.\n\n## Current Behavior\n- `TerminalView.hasProcessExited()` triggers `NSApp.terminate()`\n- User must re-launch Shade after every nvim session\n\n## Desired Behavior\n- nvim :wq → hide panel, keep Shade running\n- nvim killed/crashed → hide panel, keep Shade running\n- Cmd+Q in Shade → actually terminate\n- io.shade.quit IPC → actually terminate\n\n## Implementation\n- Remove/modify the termination logic in tick timer\n- On process exit: destroy surface, hide panel, await new surface creation\n- Track 'has active surface' state\n- Add quit notification handler\n\n## Edge Cases\n- Multiple rapid toggles while no surface exists\n- Surface creation failure after process exit","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T09:02:34.314821-05:00","created_by":"seth","updated_at":"2026-01-07T09:23:03.952435-05:00","closed_at":"2026-01-07T09:23:03.952435-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-141.2","depends_on_id":"shade-141","type":"parent-child","created_at":"2026-01-07T09:02:34.31537-05:00","created_by":"seth"}]}
{"id":"shade-141.3","title":"Add XDG directory support for state files","description":"Use XDG Base Directory spec for Shade's runtime state.\n\n## Directory Structure\n```\n~/.local/state/shade/\n├── context.json    # Capture context (written by Hammerspoon)\n├── nvim.sock       # Nvim RPC socket path\n└── shade.pid       # PID file for process management\n```\n\n## Implementation\n- Create StateDirectory helper in Swift\n- Auto-create directory on launch if missing\n- Write PID file on launch, remove on clean shutdown\n- Update nvim socket path in launch command\n- Expose paths via CLI flags or environment for Hammerspoon\n\n## Considerations\n- Handle existing /tmp paths gracefully during transition\n- Document XDG paths in README","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T09:02:38.625725-05:00","created_by":"seth","updated_at":"2026-01-07T09:24:18.365254-05:00","closed_at":"2026-01-07T09:24:18.365254-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-141.3","depends_on_id":"shade-141","type":"parent-child","created_at":"2026-01-07T09:02:38.626362-05:00","created_by":"seth"}]}
{"id":"shade-141.4","title":"Implement io.shade.note.capture IPC handler","description":"Handle quick capture requests from Hammerspoon.\n\n## IPC Flow\n1. Hammerspoon gathers context, writes to ~/.local/state/shade/context.json\n2. Hammerspoon sends io.shade.note.capture notification\n3. Shade reads context.json\n4. Shade shows panel\n5. Shade sends RPC to nvim: open new capture file (or use obsidian.nvim command)\n\n## Context JSON Schema\n```json\n{\n  \"appType\": \"browser|terminal|neovim|other\",\n  \"appName\": \"Brave Browser\",\n  \"windowTitle\": \"GitHub - ...\",\n  \"url\": \"https://...\",\n  \"filePath\": \"/path/to/file\",\n  \"selection\": \"selected text\",\n  \"detectedLanguage\": \"lua\",\n  \"timestamp\": \"2026-01-07T12:00:00Z\"\n}\n```\n\n## Implementation\n- Add notification observer for io.shade.note.capture\n- Read and parse context.json\n- If no surface exists, create one\n- Send nvim RPC command to open capture file\n- Show panel\n\n## Dependencies\n- Requires background-on-exit (surface may not exist)\n- Requires XDG directories (context.json path)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T09:02:44.269753-05:00","created_by":"seth","updated_at":"2026-01-07T09:25:53.087762-05:00","closed_at":"2026-01-07T09:25:53.087762-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-141.4","depends_on_id":"shade-141","type":"parent-child","created_at":"2026-01-07T09:02:44.270385-05:00","created_by":"seth"},{"issue_id":"shade-141.4","depends_on_id":"shade-141.2","type":"blocks","created_at":"2026-01-07T09:03:47.725346-05:00","created_by":"seth"},{"issue_id":"shade-141.4","depends_on_id":"shade-141.3","type":"blocks","created_at":"2026-01-07T09:03:47.763122-05:00","created_by":"seth"}]}
{"id":"shade-141.5","title":"Implement io.shade.note.daily IPC handler","description":"Handle daily note requests from Hammerspoon.\n\n## IPC Flow\n1. Hammerspoon sends io.shade.note.daily notification\n2. Shade shows panel\n3. Shade sends RPC to nvim to open daily note\n\n## Implementation Options\n\n### Option A: Let obsidian.nvim handle it\n- Send nvim RPC: `nvim_command('ObsidianToday')`\n- obsidian.nvim creates file with template if needed\n- Requires obsidian.nvim to be configured for daily notes\n\n### Option B: Shade computes path, nvim just opens\n- Shade computes: `~/notes/daily/2026/20260107.md`\n- Send nvim RPC: `nvim_command('edit ' .. path)`\n- File creation/templating happens elsewhere (shell script still)\n\n## Current Recommendation\n- Start with Option B (matches current workflow)\n- Migrate to Option A when obsidian.nvim templating is enhanced\n\n## Dependencies\n- Requires background-on-exit (surface may not exist)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T09:02:49.408173-05:00","created_by":"seth","updated_at":"2026-01-07T09:25:57.17003-05:00","closed_at":"2026-01-07T09:25:57.17003-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-141.5","depends_on_id":"shade-141","type":"parent-child","created_at":"2026-01-07T09:02:49.408786-05:00","created_by":"seth"},{"issue_id":"shade-141.5","depends_on_id":"shade-141.2","type":"blocks","created_at":"2026-01-07T09:03:47.799844-05:00","created_by":"seth"}]}
{"id":"shade-141.6","title":"Add emergency escape hotkey (Cmd+Escape)","description":"Register a global hotkey as emergency dismiss, independent of Hammerspoon.\n\n## Goal\nWhen Hammerspoon breaks, user can still dismiss Shade with Cmd+Escape (or configured key).\n\n## Implementation Approach\nUse CGEvent tap to register global hotkey:\n1. Request Accessibility permissions (likely already granted for get-selection)\n2. Create CGEvent tap for keyDown events\n3. Check for Cmd+Escape combination\n4. On match: hide panel, return true (consume event)\n\n## Considerations\n- Should this work even when Shade is hidden? (Probably no-op)\n- What if Accessibility permissions denied? (Log warning, continue without hotkey)\n- Should hotkey be configurable? (Future: via config file)\n\n## Alternative: NSEvent.addGlobalMonitorForEvents\n- Simpler API but less reliable for key consumption\n- May not work if another app has captured the key\n\n## Verification\n- Launch Shade\n- Kill Hammerspoon\n- Press Cmd+Escape\n- Shade should hide","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-07T09:02:55.495287-05:00","created_by":"seth","updated_at":"2026-01-07T09:34:07.129171-05:00","closed_at":"2026-01-07T09:34:07.129171-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-141.6","depends_on_id":"shade-141","type":"parent-child","created_at":"2026-01-07T09:02:55.495917-05:00","created_by":"seth"}]}
{"id":"shade-141.7","title":"Add Cmd+Q handler for actual quit","description":"Distinguish between 'hide on process exit' and 'actually quit the app'.\n\n## Current State\n- No explicit quit handling\n- App quits when child process exits\n\n## Desired Behavior\n- Cmd+Q in Shade window → terminate app\n- io.shade.quit IPC → terminate app\n- Child process exit → hide panel, keep running\n\n## Implementation\n- Add menu bar (even if hidden) with Quit item for Cmd+Q\n- Or: capture Cmd+Q in key event handling\n- Add io.shade.quit notification observer\n- Both trigger NSApp.terminate()\n\n## Considerations\n- Shade runs as .accessory (no dock icon) - does Cmd+Q still work?\n- May need to temporarily become .regular to receive Cmd+Q?\n- Alternative: capture in global hotkey system","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-07T09:03:00.393904-05:00","created_by":"seth","updated_at":"2026-01-07T09:25:01.1793-05:00","closed_at":"2026-01-07T09:25:01.1793-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-141.7","depends_on_id":"shade-141","type":"parent-child","created_at":"2026-01-07T09:03:00.394451-05:00","created_by":"seth"}]}
{"id":"shade-141.8","title":"Implement nvim RPC communication","description":"Add ability to send commands to nvim via Unix socket RPC.\n\n## Current State\n- nvim launched with: --listen /tmp/nvim-capture.sock\n- Hammerspoon can send RPC commands\n- Shade cannot (no RPC client)\n\n## Required for\n- Opening files in existing nvim session (capture, daily note)\n- Checking buffer state before switching\n- Future: sending save commands\n\n## Implementation\nUse nvim's msgpack-rpc protocol over Unix socket:\n1. Connect to socket at ~/.local/state/shade/nvim.sock\n2. Send nvim_command() RPC calls\n3. Handle connection failures gracefully (nvim not running)\n\n## Swift Options\n- Raw socket + msgpack encoding (complex)\n- Shell out to nvr/nvim --remote (simpler, adds dependency)\n- Use Process to run: nvim --server \u003csock\u003e --remote-send '\u003ccmd\u003e'\n\n## Recommended: Start with Process/nvim --server\n```swift\nProcess.run(\n  \"/usr/bin/env\", \"nvim\",\n  \"--server\", socketPath,\n  \"--remote-send\", \"\u003cC-\\\\\u003e\u003cC-n\u003e:edit \\(path)\u003cCR\u003e\"\n)\n```\n\n## Considerations\n- What if nvim isn't running? Create new surface with nvim\n- What if socket doesn't exist? Same as above\n- Race conditions between surface creation and RPC","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-07T09:03:08.61901-05:00","created_by":"seth","updated_at":"2026-01-07T09:32:47.882087-05:00","closed_at":"2026-01-07T09:32:47.882087-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-141.8","depends_on_id":"shade-141","type":"parent-child","created_at":"2026-01-07T09:03:08.619622-05:00","created_by":"seth"},{"issue_id":"shade-141.8","depends_on_id":"shade-141.3","type":"blocks","created_at":"2026-01-07T09:03:47.835983-05:00","created_by":"seth"}]}
{"id":"shade-141.9","title":"Update documentation and README for Shade","description":"Comprehensive documentation update after rename.\n\n## Updates Required\n- [ ] README.md: new name, updated architecture diagram\n- [ ] README.md: document XDG paths\n- [ ] README.md: document new IPC namespace\n- [ ] README.md: document emergency hotkey\n- [ ] Update justfile comments\n- [ ] Add CHANGELOG.md entry for rename\n\n## New Sections to Add\n- IPC Protocol reference\n- XDG directory structure\n- Hammerspoon integration guide (link to dotfiles epic)","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-07T09:03:15.591985-05:00","created_by":"seth","updated_at":"2026-01-07T09:35:24.759631-05:00","closed_at":"2026-01-07T09:35:24.759631-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-141.9","depends_on_id":"shade-141","type":"parent-child","created_at":"2026-01-07T09:03:15.592563-05:00","created_by":"seth"}]}
{"id":"shade-2hs","title":"Debug Shade + Hammerspoon integration issues","description":"Debug and fix the Shade + Hammerspoon integration after the shade-qji context gathering refactor.\n\n## Problem\nAfter refactoring Hammerspoon to use notification pattern (io.shade.note.daily, io.shade.note.capture), the daily note and capture workflows are broken.\n\n## Evidence\n- Shade IS running with correct args (--command, --working-directory)\n- nvim socket EXISTS and RESPONDS (v:version returns 801)\n- But: errors.log shows 'timeout waiting for nvim server to send: :ObsidianToday'\n\n## Hypothesis\nThe notification handlers in Shade (ShadeAppDelegate.swift) may not be correctly wired up, OR ShadeNvim actor is failing to connect/execute commands.\n\n## Key Files\n- ~/.dotfiles/config/hammerspoon/lib/interop/shade.lua\n- ~/.dotfiles/config/hammerspoon/bindings.lua\n- ~/code/shade/Sources/ShadeAppDelegate.swift\n- ~/code/shade/Sources/ShadeNvim.swift","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-08T14:47:07.406511-05:00","created_by":"seth","updated_at":"2026-01-08T14:47:16.098183-05:00"}
{"id":"shade-2hs.1","title":"Verify notification handlers are registered in ShadeAppDelegate","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T14:47:20.230882-05:00","created_by":"seth","updated_at":"2026-01-08T14:47:20.230882-05:00","dependencies":[{"issue_id":"shade-2hs.1","depends_on_id":"shade-2hs","type":"parent-child","created_at":"2026-01-08T14:47:20.231568-05:00","created_by":"seth"}]}
{"id":"shade-2hs.2","title":"Test io.shade.note.daily notification delivery and handler execution","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T14:47:20.900813-05:00","created_by":"seth","updated_at":"2026-01-08T14:47:20.900813-05:00","dependencies":[{"issue_id":"shade-2hs.2","depends_on_id":"shade-2hs","type":"parent-child","created_at":"2026-01-08T14:47:20.901519-05:00","created_by":"seth"}]}
{"id":"shade-2hs.3","title":"Debug ShadeNvim.connectAndPerform flow for openDailyNote","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T14:47:22.058916-05:00","created_by":"seth","updated_at":"2026-01-08T14:47:22.058916-05:00","dependencies":[{"issue_id":"shade-2hs.3","depends_on_id":"shade-2hs","type":"parent-child","created_at":"2026-01-08T14:47:22.059609-05:00","created_by":"seth"}]}
{"id":"shade-2hs.4","title":"Test io.shade.note.capture notification and context gathering","status":"in_progress","priority":2,"issue_type":"task","created_at":"2026-01-08T14:47:22.891204-05:00","created_by":"seth","updated_at":"2026-01-08T14:52:58.792381-05:00","dependencies":[{"issue_id":"shade-2hs.4","depends_on_id":"shade-2hs","type":"parent-child","created_at":"2026-01-08T14:47:22.89186-05:00","created_by":"seth"}]}
{"id":"shade-2hs.5","title":"Fix screen positioning (Shade uses NSScreen.main instead of primary)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-08T14:47:23.918592-05:00","created_by":"seth","updated_at":"2026-01-08T14:47:23.918592-05:00","dependencies":[{"issue_id":"shade-2hs.5","depends_on_id":"shade-2hs","type":"parent-child","created_at":"2026-01-08T14:47:23.919242-05:00","created_by":"seth"}]}
{"id":"shade-2i2","title":"Add menubar icon using SF Symbol pin rotated 45 degrees","description":"Add a menubar status item for Shade with a recognizable icon.\n\n## Icon\n- Use SF Symbol: selection.pin.in.out\n- Rotate 45 degrees for visual distinction\n- Should work in light and dark mode\n\n## Menubar Functionality\n- Click to toggle panel visibility\n- Right-click or long-press for menu:\n  - Show/Hide\n  - Open Daily Note\n  - New Capture\n  - Separator\n  - Quit\n\n## Implementation Notes\n- Use NSStatusItem with NSStatusBar.system\n- NSImage(systemSymbolName:accessibilityDescription:) for SF Symbol\n- Apply CGAffineTransform for rotation\n- Consider using template image for auto dark/light adaptation\n\n## Acceptance Criteria\n- Icon visible in menubar when Shade running\n- Click toggles panel\n- Menu provides quick actions\n- Works correctly in light and dark mode","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-08T09:35:13.323623-05:00","created_by":"seth","updated_at":"2026-01-08T10:21:30.327388-05:00","closed_at":"2026-01-08T10:21:30.327388-05:00","close_reason":"Closed"}
{"id":"shade-3os","title":"Add io.shade.note.capture.image notification handler","description":"Add handler for image captures from clipper module.\n\nClipper writes context with imageFilename, then sends io.shade.note.capture.image notification.\nShade needs to:\n1. Read context (with imageFilename field)\n2. Run :Obsidian new_from_template capture capture-image\n3. Show panel (for captureFull) or stay hidden (for captureQuick)\n\nRequired changes:\n- ShadeAppDelegate.swift: Add handleImageCaptureNotification handler\n- StateDirectory.swift/CaptureContext: Add imageFilename field\n- ShadeNvim.swift: Add openImageCapture() method","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-08T12:32:45.757317-05:00","created_by":"seth","updated_at":"2026-01-08T12:34:32.905607-05:00","closed_at":"2026-01-08T12:34:32.905607-05:00","close_reason":"Closed"}
{"id":"shade-4u3","title":"Fix: capture notification early-return prevented new captures when panel visible","description":"When panel was already visible, handleNoteCaptureNotification() would just focus the panel and return early instead of creating a new capture. This broke the Hyper+Shift+N workflow when daily note was open.\n\nFix: Remove the early-return logic - always create a new capture when user explicitly requests one.","status":"open","priority":1,"issue_type":"bug","created_at":"2026-01-08T15:47:00.653518-05:00","created_by":"seth","updated_at":"2026-01-08T15:47:00.653518-05:00"}
{"id":"shade-d5b","title":"Bidirectional RPC: Nvim-to-Shade communication","description":"Enable nvim (and other processes running inside shade) to call back to shade via RPC.\n\n## Motivation\nCurrently communication is one-way:\n- Hammerspoon/Shell → Shade (distributed notifications)\n- Shade → Nvim (msgpack-rpc socket)\n\nBut nvim cannot easily communicate back to shade (only via shell-out to swift).\n\n## Goals\n- Shade listens on its own RPC socket (~/.local/state/shade/shade.sock)\n- Nvim can connect and call shade methods\n- Provide a nvim Lua module for easy integration\n\n## Use Cases\n1. Nvim tells shade to hide after :wq (without relying on process exit detection)\n2. Nvim requests the capture context directly\n3. Nvim triggers shade to gather fresh context from frontmost app\n4. Custom nvim commands that interact with shade\n\n## API Design (tentative)\n```lua\n-- In nvim\nlocal shade = require('shade')\nshade.hide()\nshade.show()\nshade.toggle()\nlocal ctx = shade.get_context()\nshade.notify('Custom message')\n```\n\n## Dependencies\n- shade-plf epic (native msgpack-rpc infrastructure)\n\n## References\n- shade-plf: Native msgpack-rpc client for nvim","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-08T08:41:28.572956-05:00","created_by":"seth","updated_at":"2026-01-08T15:04:26.310846-05:00","closed_at":"2026-01-08T15:04:26.310846-05:00","close_reason":"Implemented bidirectional RPC: ShadeServer.swift, shade.lua nvim module, tests"}
{"id":"shade-d5b.1","title":"Shade listens on shade.sock as msgpack-rpc server","description":"Add a second socket (shade.sock) where Shade acts as the SERVER, not client. Nvim and other processes can connect and send commands.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-08T14:56:21.510937-05:00","created_by":"seth","updated_at":"2026-01-08T15:00:14.430992-05:00","closed_at":"2026-01-08T15:00:14.430992-05:00","close_reason":"Implemented ShadeServer.swift - listens on shade.sock","dependencies":[{"issue_id":"shade-d5b.1","depends_on_id":"shade-d5b","type":"parent-child","created_at":"2026-01-08T14:56:21.511946-05:00","created_by":"seth"}]}
{"id":"shade-d5b.2","title":"Implement Shade RPC methods: hide, show, toggle, get_context","description":"Handle incoming RPC requests from nvim. Methods: hide(), show(), toggle(), get_context() -\u003e returns current capture context.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-08T14:56:23.082052-05:00","created_by":"seth","updated_at":"2026-01-08T15:00:15.236581-05:00","closed_at":"2026-01-08T15:00:15.236581-05:00","close_reason":"Implemented hide, show, toggle, get_context, ping methods","dependencies":[{"issue_id":"shade-d5b.2","depends_on_id":"shade-d5b","type":"parent-child","created_at":"2026-01-08T14:56:23.082699-05:00","created_by":"seth"}]}
{"id":"shade-d5b.3","title":"Create nvim Lua module: shade.nvim","description":"Lua module that connects to shade.sock and provides: require('shade').hide(), .show(), .toggle(), .get_context(). Lives in dotfiles nvim config.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-08T14:56:24.412741-05:00","created_by":"seth","updated_at":"2026-01-08T15:04:04.86721-05:00","closed_at":"2026-01-08T15:04:04.86721-05:00","close_reason":"Created shade.lua nvim module with hide/show/toggle/ping/get_context","dependencies":[{"issue_id":"shade-d5b.3","depends_on_id":"shade-d5b","type":"parent-child","created_at":"2026-01-08T14:56:24.413461-05:00","created_by":"seth"}]}
{"id":"shade-d5b.4","title":"Wire up persistent nvim: QuitPre calls shade.hide()","description":"In notes.lua, the QuitPre autocmd calls require('shade').hide() instead of relying on process exit. This completes the persistent nvim flow.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-08T14:56:25.925858-05:00","created_by":"seth","updated_at":"2026-01-08T15:04:06.283927-05:00","closed_at":"2026-01-08T15:04:06.283927-05:00","close_reason":"shade.setup() in notes.lua wires up QuitPre to call shade.hide()","dependencies":[{"issue_id":"shade-d5b.4","depends_on_id":"shade-d5b","type":"parent-child","created_at":"2026-01-08T14:56:25.926525-05:00","created_by":"seth"}]}
{"id":"shade-gc6","title":"shade-ctl: CLI helper for shell integration","description":"Create a lightweight CLI tool (or shade subcommands) for easy shell integration.\n\n## Motivation\nCurrently, sending commands to shade from shell requires a verbose Swift one-liner:\n```bash\nswift -e 'import Foundation; DistributedNotificationCenter.default().post(name: NSNotification.Name(\"io.shade.toggle\"), object: nil)'\n```\n\n## Goals\n- Simple CLI interface for all shade IPC commands\n- Fast execution (no Swift compilation overhead)\n- Tab completion support\n\n## Design Options\n\n### Option A: Separate shade-ctl binary\n```bash\nshade-ctl toggle\nshade-ctl show\nshade-ctl hide\nshade-ctl quit\nshade-ctl capture [--context file.json]\nshade-ctl daily\nshade-ctl status  # Check if shade is running\n```\n\n### Option B: Subcommands in shade itself\n```bash\nshade ctl toggle\nshade ctl capture\n# or\nshade --send toggle\nshade --send capture\n```\n\n### Option C: Shell functions (no new binary)\n```bash\n# In .zshrc\nshade-toggle() { swift -e '...' }\n```\n\n## Implementation Notes\n- Could be a small Swift CLI that just sends notifications\n- Or a shell script wrapper\n- Consider using osascript for faster execution than swift -e\n\n## Dependencies\nNone (standalone)","status":"open","priority":3,"issue_type":"epic","created_at":"2026-01-08T08:41:40.059706-05:00","created_by":"seth","updated_at":"2026-01-08T08:41:40.059706-05:00"}
{"id":"shade-plf","title":"Native msgpack-rpc client for nvim","description":"Implement a native Swift msgpack-rpc client to communicate with nvim directly over Unix socket, replacing the current shell-out approach.\n\n## Goals\n- Persistent socket connection to nvim (no process spawn per command)\n- Full access to nvim's 400+ API functions\n- Bidirectional communication: Shade → Nvim AND Nvim → Shade\n- Async notifications for buffer changes, saves, etc.\n\n## Non-Goals (for now)\n- Full UI rendering (that's what VimR does)\n- Replacing ghostty terminal emulation\n\n## Architecture\n```\nShade ←→ Unix Socket ←→ Nvim\n         (msgpack-rpc)\n\n~/.local/state/shade/nvim.sock\n```\n\n## Key Capabilities Unlocked\n1. Call any nvim API function directly\n2. Get return values from nvim\n3. Subscribe to buffer events (nvim_buf_attach)\n4. Know when user saves, changes buffers, etc.\n5. Execute Lua code in nvim context\n6. Read/write buffer content programmatically\n\n## Dependencies\n- MessagePack.swift (a2/MessagePack.swift) or manual encoding\n- Existing Unix socket infrastructure in Shade\n\n## References\n- Nvim API: https://neovim.io/doc/user/api.html\n- Msgpack-RPC spec: https://github.com/msgpack-rpc/msgpack-rpc/blob/master/spec.md\n- VimR NvimApi: https://github.com/qvacua/vimr/tree/master/NvimApi","status":"closed","priority":2,"issue_type":"epic","created_at":"2026-01-07T15:50:50.44624-05:00","created_by":"seth","updated_at":"2026-01-08T09:46:50.942627-05:00","closed_at":"2026-01-08T09:46:50.942627-05:00","close_reason":"Closed"}
{"id":"shade-plf.1","title":"Add MessagePack.swift dependency via SPM","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T15:51:59.712486-05:00","created_by":"seth","updated_at":"2026-01-07T16:40:13.29822-05:00","closed_at":"2026-01-07T16:40:13.29822-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-plf.1","depends_on_id":"shade-plf","type":"parent-child","created_at":"2026-01-07T15:51:59.713126-05:00","created_by":"seth"}]}
{"id":"shade-plf.10","title":"Add resilience to nvim crashes and connection failures","description":"Ensure Shade handles nvim connection issues gracefully:\n\n## Scenarios to Handle\n- Nvim crashes while Shade is connected\n- Nvim socket disappears (process killed)\n- Nvim hangs/becomes unresponsive\n- Connection timeout during startup\n- Socket exists but nvim not responding\n\n## Required Behavior\n- Detect disconnection and update state\n- Auto-reconnect when nvim restarts\n- Don't block UI on connection issues\n- Clear error messages in logs\n- Graceful degradation (panel still works, just no RPC)\n\n## Implementation\n- Monitor socket for EOF/errors\n- Implement heartbeat or keepalive\n- Add connection state observable for UI feedback\n- Timeout long-running requests\n\n## Acceptance Criteria\n- Kill nvim while connected: Shade detects and logs, no crash\n- Restart nvim: Shade reconnects on next command\n- Hang nvim: Request times out, error logged, UI responsive","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-08T09:35:03.730534-05:00","created_by":"seth","updated_at":"2026-01-08T09:40:34.247603-05:00","closed_at":"2026-01-08T09:40:34.247603-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-plf.10","depends_on_id":"shade-plf","type":"parent-child","created_at":"2026-01-08T09:35:03.731274-05:00","created_by":"seth"}]}
{"id":"shade-plf.2","title":"Implement Unix socket connection manager for nvim","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T15:52:00.330496-05:00","created_by":"seth","updated_at":"2026-01-07T16:46:22.014746-05:00","closed_at":"2026-01-07T16:46:22.014746-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-plf.2","depends_on_id":"shade-plf","type":"parent-child","created_at":"2026-01-07T15:52:00.333338-05:00","created_by":"seth"},{"issue_id":"shade-plf.2","depends_on_id":"shade-plf.1","type":"blocks","created_at":"2026-01-07T15:52:08.777686-05:00","created_by":"seth"}]}
{"id":"shade-plf.3","title":"Implement msgpack-rpc protocol encoder/decoder","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T15:52:00.94768-05:00","created_by":"seth","updated_at":"2026-01-07T16:52:10.134967-05:00","closed_at":"2026-01-07T16:52:10.134967-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-plf.3","depends_on_id":"shade-plf","type":"parent-child","created_at":"2026-01-07T15:52:00.967753-05:00","created_by":"seth"},{"issue_id":"shade-plf.3","depends_on_id":"shade-plf.1","type":"blocks","created_at":"2026-01-07T15:52:08.847247-05:00","created_by":"seth"}]}
{"id":"shade-plf.4","title":"Implement request/response handling with msgid correlation","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T15:52:01.545189-05:00","created_by":"seth","updated_at":"2026-01-07T16:59:44.112631-05:00","closed_at":"2026-01-07T16:59:44.112631-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-plf.4","depends_on_id":"shade-plf","type":"parent-child","created_at":"2026-01-07T15:52:01.54872-05:00","created_by":"seth"},{"issue_id":"shade-plf.4","depends_on_id":"shade-plf.2","type":"blocks","created_at":"2026-01-07T15:52:08.920575-05:00","created_by":"seth"},{"issue_id":"shade-plf.4","depends_on_id":"shade-plf.3","type":"blocks","created_at":"2026-01-07T15:52:08.989644-05:00","created_by":"seth"}]}
{"id":"shade-plf.5","title":"Implement async notification subscription system","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-07T15:52:02.144288-05:00","created_by":"seth","updated_at":"2026-01-08T08:43:42.287542-05:00","closed_at":"2026-01-08T08:43:42.287542-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-plf.5","depends_on_id":"shade-plf","type":"parent-child","created_at":"2026-01-07T15:52:02.146889-05:00","created_by":"seth"},{"issue_id":"shade-plf.5","depends_on_id":"shade-plf.4","type":"blocks","created_at":"2026-01-07T15:52:09.889984-05:00","created_by":"seth"}]}
{"id":"shade-plf.6","title":"Create high-level NvimAPI wrapper with typed methods","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-07T15:52:02.642145-05:00","created_by":"seth","updated_at":"2026-01-08T08:56:17.359225-05:00","closed_at":"2026-01-08T08:56:17.359225-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-plf.6","depends_on_id":"shade-plf","type":"parent-child","created_at":"2026-01-07T15:52:02.642888-05:00","created_by":"seth"},{"issue_id":"shade-plf.6","depends_on_id":"shade-plf.4","type":"blocks","created_at":"2026-01-07T15:52:09.951767-05:00","created_by":"seth"}]}
{"id":"shade-plf.7","title":"Replace shell-out IPC handlers with native msgpack-rpc calls","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-07T15:52:03.294333-05:00","created_by":"seth","updated_at":"2026-01-08T09:29:05.641202-05:00","closed_at":"2026-01-08T09:29:05.641202-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-plf.7","depends_on_id":"shade-plf","type":"parent-child","created_at":"2026-01-07T15:52:03.297203-05:00","created_by":"seth"},{"issue_id":"shade-plf.7","depends_on_id":"shade-plf.6","type":"blocks","created_at":"2026-01-07T15:52:10.09871-05:00","created_by":"seth"}]}
{"id":"shade-plf.8","title":"Implement nvim_buf_attach for buffer change notifications","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-07T15:52:03.88837-05:00","created_by":"seth","updated_at":"2026-01-08T09:46:33.304065-05:00","closed_at":"2026-01-08T09:46:33.304065-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-plf.8","depends_on_id":"shade-plf","type":"parent-child","created_at":"2026-01-07T15:52:03.891098-05:00","created_by":"seth"},{"issue_id":"shade-plf.8","depends_on_id":"shade-plf.5","type":"blocks","created_at":"2026-01-07T15:52:10.166752-05:00","created_by":"seth"}]}
{"id":"shade-plf.9","title":"Validate memory and CPU efficiency of native RPC implementation","description":"Profile and validate that the native msgpack-rpc implementation is efficient:\n\n## Memory\n- Verify no memory leaks in socket connection lifecycle\n- Check buffer handling in stream decoding doesn't accumulate\n- Ensure proper cleanup on disconnect\n\n## CPU\n- Verify idle CPU usage is minimal when connected but inactive\n- Check that read source doesn't spin\n- Profile tick timer interaction with socket I/O\n\n## Tools\n- Instruments (Allocations, Time Profiler, Leaks)\n- Activity Monitor baseline comparison vs old shell-out approach\n\n## Acceptance Criteria\n- No memory growth over extended use (hours)\n- Idle CPU \u003c 1% when panel hidden\n- No regression vs shell-out approach","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-08T09:34:54.125197-05:00","created_by":"seth","updated_at":"2026-01-08T09:40:34.183989-05:00","closed_at":"2026-01-08T09:40:34.183989-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-plf.9","depends_on_id":"shade-plf","type":"parent-child","created_at":"2026-01-08T09:34:54.125901-05:00","created_by":"seth"}]}
{"id":"shade-qji","title":"Context Gathering in Shade (Sub-Epic)","description":"Port context gathering from Hammerspoon to Shade, making Shade self-sufficient for capturing context from the frontmost app.\n\n## Background\nCurrently Hammerspoon orchestrates context gathering via:\n- `bin/get-selection` Swift script (Accessibility API)\n- `lib/interop/context.lua` (app type detection, browser JXA)\n- `lib/interop/nvim.lua` (nvim RPC for buffer info)\n- `lib/interop/shade.lua` (writes context.json)\n\n## Goal\nShade gathers context itself when quick capture is triggered, eliminating Hammerspoon as middleman.\n\n## Architecture\n```\nContextGatherer.swift\n├── AXUIElement → selectedText, windowTitle, bundleID\n├── JXABridge → browser URLs, selections  \n├── NvimAPI (existing!) → buffer info, selection\n└── AppTypeDetector → browser/terminal/editor/other\n```\n\n## Messages.app Note\nUser will use standard copy/paste for selection - no exotic clipboard monitoring needed.\n\n## Research Notes (Jan 2026)\n\n### Related Libraries Evaluated\n1. **AXSwift** (tmandry, 397 stars) - Swift wrapper for AX APIs. Good Observer API but synchronous-only. Used by Swindler and Hammerspoon2.\n2. **Swindler** (tmandry, 732 stars) - Window management with in-memory state cache. Key insight: caches all window states so reads are instant.\n3. **Hammerspoon2** (cmsj, 45 stars) - Swift rewrite using AXSwift internally. Confirms our architecture approach is sound.\n4. **AXorcist** (steipete, 133 stars) - Modern query-based AX automation. Elegant declarative element finding pattern worth adopting later.\n\n### Key Insights\n- None of these libraries handle JXA/AppleScript - our Process+osascript approach is correct\n- Swindler's in-memory caching pattern could help with rapid captures\n- AXorcist's declarative query pattern (`findElement(matching: [.role(.button), .title(\"Back\")])`) is cleaner than tree walking\n- Our AccessibilityHelper is comparable to AXSwift's core functionality\n","status":"closed","priority":3,"issue_type":"epic","created_at":"2026-01-08T10:48:19.138249-05:00","created_by":"seth","updated_at":"2026-01-08T12:16:54.611701-05:00","closed_at":"2026-01-08T12:16:54.611701-05:00","close_reason":"Closed"}
{"id":"shade-qji.1","title":"Port get-selection Swift logic into Shade","description":"Port the existing `bin/get-selection` Swift script functionality directly into Shade.\n\n## Approach\nBuild from scratch using native Swift Accessibility framework - NOT porting Lua or shelling out.\n\n## Swift APIs to Use\n- `AXUIElementCreateSystemWide()` - Get system-wide element\n- `kAXFocusedUIElementAttribute` - Get focused element  \n- `kAXSelectedTextAttribute` - Get selected text (clipboard-free!)\n- `kAXTitleAttribute` - Get window title\n- `kAXDocumentAttribute` - Get browser URL (AXDocument)\n- `NSWorkspace.shared.frontmostApplication` - Get frontmost app\n\n## Target\nCreate `Sources/ContextGatherer/AccessibilityHelper.swift`:\n```swift\nimport ApplicationServices\nimport AppKit\n\nprotocol AccessibilityProviding {\n    func getFocusedElement() -\u003e AXUIElement?\n    func getSelectedText(from element: AXUIElement) -\u003e String?\n    func getWindowTitle(from app: NSRunningApplication) -\u003e String?\n    func getDocumentURL(from element: AXUIElement) -\u003e String?\n}\n\nclass AccessibilityHelper: AccessibilityProviding {\n    static let shared = AccessibilityHelper()\n    // Implementation...\n}\n```\n\n## Testing Strategy\n- Protocol abstraction (`AccessibilityProviding`) for mocking in tests\n- Unit tests for any data transformation logic\n- Integration tests (skipped in CI) that verify against real apps\n\n## Notes\n- Shade already requires Accessibility permissions (for GlobalHotkey CGEvent tap)\n- No new permissions needed\n- This is the foundation for all other context gathering","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-08T10:48:32.690095-05:00","created_by":"seth","updated_at":"2026-01-08T11:00:27.104661-05:00","closed_at":"2026-01-08T11:00:27.104661-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-qji.1","depends_on_id":"shade-qji","type":"parent-child","created_at":"2026-01-08T10:48:32.690826-05:00","created_by":"seth"}]}
{"id":"shade-qji.2","title":"Add app type detection","description":"Port Hammerspoon's app type detection logic to Swift.\n\n## Current Implementation\nIn `lib/interop/context.lua`:\n- Browser detection via bundle ID patterns + AXDocument URL check\n- Terminal detection via bundle ID patterns\n- Neovim detection via nvim socket existence\n- Editor detection via bundle ID patterns\n\n## Bundle ID Patterns to Port\n```lua\n-- Browsers\n'com.brave.Browser', 'com.google.Chrome', 'com.apple.Safari', \n'company.thebrowser.Browser' (Arc), 'org.mozilla.firefox'\n\n-- Terminals  \n'net.kovidgoyal.kitty', 'com.mitchellh.ghostty', 'com.apple.Terminal',\n'com.googlecode.iterm2'\n\n-- Editors\n'com.microsoft.VSCode', 'com.apple.dt.Xcode'\n```\n\n## Target\n```swift\nenum AppType: String, Codable {\n    case browser, terminal, neovim, editor, other\n}\n\nclass AppTypeDetector {\n    static func detect(bundleID: String, windowTitle: String?, axDocument: String?) -\u003e AppType\n}\n```\n\n## Depends On\n- shade-qji.1 (AccessibilityHelper for bundleID, axDocument)","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-08T10:48:42.542145-05:00","created_by":"seth","updated_at":"2026-01-08T11:09:57.684744-05:00","closed_at":"2026-01-08T11:09:57.684744-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-qji.2","depends_on_id":"shade-qji","type":"parent-child","created_at":"2026-01-08T10:48:42.542862-05:00","created_by":"seth"},{"issue_id":"shade-qji.2","depends_on_id":"shade-qji.1","type":"blocks","created_at":"2026-01-08T10:49:43.666274-05:00","created_by":"seth"}]}
{"id":"shade-qji.3","title":"Add JXA bridge for browser context","description":"Add ability to execute JXA (JavaScript for Automation) to get browser-specific context.\n\n## Current Implementation\nIn `lib/interop/context.lua`, uses `hs.osascript.javascript()`:\n\n### Chrome-based browsers:\n```javascript\nvar browser = Application('Brave Browser');\nvar win = browser.windows[0];\nvar tab = win.activeTab;\nreturn {\n    url: tab.url(),\n    title: tab.title(),\n    selection: browser.execute(tab, {javascript: 'window.getSelection().toString()'})\n};\n```\n\n### Safari:\n```javascript\nvar safari = Application('Safari');\nvar tab = safari.windows[0].currentTab;\nvar selection = safari.doJavaScript('window.getSelection().toString()', {in: tab});\nreturn { url: tab.url(), title: tab.name(), selection: selection };\n```\n\n## Swift Implementation\nUse `Process` + `osascript -l JavaScript` with async termination handler.\nThis approach confirmed by research - no Swift library handles JXA natively.\n\n### Key Implementation Details\n- Scripts return JSON for easy parsing\n- Use `withCheckedContinuation` + `terminationHandler` for async\n- Timeout via Task group race pattern\n- Safari uses different API (`doJavaScript` vs `execute`)\n- Firefox has NO in-page JS execution (selection will be nil)\n\n## Target API\n```swift\npublic final class JXABridge: Sendable {\n    public static let shared = JXABridge()\n    \n    public func getBrowserContext(\n        for browserInfo: BrowserInfo,\n        timeout: Duration = .seconds(2)\n    ) async -\u003e BrowserContext?\n}\n\npublic struct BrowserContext: Sendable {\n    public let url: String?\n    public let title: String?\n    public let selection: String?\n}\n```\n\n## Supported Browsers\n- Brave Browser (all variants) - Chromium API\n- Google Chrome (+ Canary) - Chromium API\n- Safari - Safari-specific API\n- Arc - Chromium API (needs testing)\n- Firefox - Limited (no tab script execution)\n\n## Areas of Concern\n1. Process.waitUntilExit() blocks - use terminationHandler instead\n2. Safari requires Automation permission (System Prefs prompt)\n3. Arc browser may have unusual window/tab structure\n4. JSON parsing needs to handle special characters in URLs/text\n\n## Research Notes\n- AXSwift/Swindler/Hammerspoon2/AXorcist all focus on AX APIs, none do JXA\n- Hammerspoon uses hs.osascript.javascript() which shells to osascript internally\n- Process+osascript is the correct and only approach\n\n## Depends On\n- shade-qji.2 (AppTypeDetector to know when to call this)\n","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-08T10:48:59.660953-05:00","created_by":"seth","updated_at":"2026-01-08T11:35:14.347496-05:00","closed_at":"2026-01-08T11:35:14.347496-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-qji.3","depends_on_id":"shade-qji","type":"parent-child","created_at":"2026-01-08T10:48:59.661657-05:00","created_by":"seth"},{"issue_id":"shade-qji.3","depends_on_id":"shade-qji.2","type":"blocks","created_at":"2026-01-08T10:49:43.727878-05:00","created_by":"seth"}]}
{"id":"shade-qji.4","title":"Integrate nvim context via existing NvimAPI","description":"Wire up existing NvimAPI to context gathering.\n\n## Current State\nShade already has full nvim RPC! From `NvimAPI.swift`:\n- `getCurrentBuffer()`, `getBufferLines()`\n- `getCurrentWindow()`, `getWindowCursor()`\n- `eval()`, `execLua()`\n\n## What Hammerspoon Currently Gathers\n```lua\nlocal luaCode = [[\n  local buf = vim.api.nvim_get_current_buf()\n  local win = vim.api.nvim_get_current_win()\n  local pos = vim.api.nvim_win_get_cursor(win)\n  return vim.json.encode({\n    path = vim.api.nvim_buf_get_name(buf),\n    name = vim.fn.expand('%:t'),\n    filetype = vim.bo[buf].filetype,\n    modified = vim.bo[buf].modified,\n    line = pos[1],\n    col = pos[2] + 1\n  })\n]]\n```\n\nAlso visual selection via '\u003c and '\u003e marks.\n\n## Target\nAdd to `ShadeNvim.swift`:\n```swift\nstruct NvimContext {\n    let filePath: String?\n    let fileName: String?\n    let filetype: String?\n    let modified: Bool\n    let line: Int\n    let col: Int\n    let selection: String?  // Visual selection if available\n}\n\nfunc getContext() async throws -\u003e NvimContext\n```\n\n## Notes\n- This is mostly wiring - the hard RPC work is done\n- Visual selection only works if in/just exited visual mode","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-08T10:49:09.078619-05:00","created_by":"seth","updated_at":"2026-01-08T11:19:53.883042-05:00","closed_at":"2026-01-08T11:19:53.883042-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-qji.4","depends_on_id":"shade-qji","type":"parent-child","created_at":"2026-01-08T10:49:09.079359-05:00","created_by":"seth"}]}
{"id":"shade-qji.5","title":"Add language detection","description":"Port Hammerspoon's language detection patterns to Swift.\n\n## Current Implementation\nIn `lib/interop/context.lua`, `detectLanguage()` uses:\n\n### 1. URL patterns\n```lua\ngithub.com/.+%.(%w+)$ → file extension\nstackoverflow.com → from code fences in selection\n```\n\n### 2. Code fence detection\n```lua\n^```(%w+) → extract language from markdown code fence\n```\n\n### 3. Shebang detection\n```lua\n^#!.*/bin/(%w+) → bash, python, ruby, etc.\n^#!.*/env%s+(%w+) → env-style shebangs\n```\n\n### 4. Filetype mapping\n```lua\nlua → lua, py → python, js → javascript, ts → typescript,\nrb → ruby, rs → rust, go → go, swift → swift, etc.\n```\n\n## Target\n```swift\nclass LanguageDetector {\n    static func detect(\n        selection: String?,\n        url: String?,\n        filetype: String?,\n        filePath: String?\n    ) -\u003e String?\n}\n```\n\n## Notes\n- Returns nil if no language detected (better than guessing)\n- Used for syntax highlighting in capture notes","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-08T10:49:18.093121-05:00","created_by":"seth","updated_at":"2026-01-08T11:17:41.233958-05:00","closed_at":"2026-01-08T11:17:41.233958-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-qji.5","depends_on_id":"shade-qji","type":"parent-child","created_at":"2026-01-08T10:49:18.093791-05:00","created_by":"seth"}]}
{"id":"shade-qji.6","title":"Wire up context gathering to capture triggers","description":"Connect all context gathering components and trigger on capture.\n\n## Current Flow\n1. Hammerspoon receives Hyper+Shift+N\n2. Hammerspoon calls `context.getContext()`\n3. Hammerspoon writes `~/.local/state/shade/context.json`\n4. Hammerspoon sends `io.shade.note.capture` to Shade\n5. Shade opens nvim with capture template\n6. obsidian.nvim reads context.json for template substitution\n\n## New Flow\n1. Hammerspoon receives Hyper+Shift+N (or Shade via shade-141.10)\n2. Hammerspoon sends `io.shade.note.capture` to Shade\n3. **Shade gathers context** via ContextGatherer\n4. Shade writes `~/.local/state/shade/context.json`\n5. Shade opens nvim with capture template\n6. obsidian.nvim reads context.json (unchanged)\n\n## Target\n```swift\nclass ContextGatherer {\n    static func gather() async -\u003e CaptureContext\n}\n\n// In ShadeAppDelegate, on io.shade.note.capture:\nlet context = await ContextGatherer.gather()\nStateDirectory.shared.writeContext(context)\n// Then open capture note as before\n```\n\n## Components Used\n- AccessibilityHelper (shade-qji.1)\n- AppTypeDetector (shade-qji.2)\n- JXABridge (shade-qji.3)\n- ShadeNvim.getContext() (shade-qji.4)\n- LanguageDetector (shade-qji.5)\n\n## Depends On\nAll previous tasks in this epic","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-08T10:49:35.05566-05:00","created_by":"seth","updated_at":"2026-01-08T12:16:10.901523-05:00","closed_at":"2026-01-08T12:16:10.901523-05:00","close_reason":"Closed","dependencies":[{"issue_id":"shade-qji.6","depends_on_id":"shade-qji","type":"parent-child","created_at":"2026-01-08T10:49:35.056279-05:00","created_by":"seth"},{"issue_id":"shade-qji.6","depends_on_id":"shade-qji.1","type":"blocks","created_at":"2026-01-08T10:49:43.793964-05:00","created_by":"seth"},{"issue_id":"shade-qji.6","depends_on_id":"shade-qji.2","type":"blocks","created_at":"2026-01-08T10:49:43.857391-05:00","created_by":"seth"},{"issue_id":"shade-qji.6","depends_on_id":"shade-qji.3","type":"blocks","created_at":"2026-01-08T10:49:43.921248-05:00","created_by":"seth"},{"issue_id":"shade-qji.6","depends_on_id":"shade-qji.4","type":"blocks","created_at":"2026-01-08T10:49:43.983508-05:00","created_by":"seth"},{"issue_id":"shade-qji.6","depends_on_id":"shade-qji.5","type":"blocks","created_at":"2026-01-08T10:49:44.04652-05:00","created_by":"seth"}]}
{"id":"shade-qji.7","title":"[Future] Declarative element query API inspired by AXorcist","description":"Refactor element finding to use a declarative query pattern instead of manual tree walking.\n\n## Inspiration\nAXorcist (steipete/AXorcist, 133 stars) uses an elegant declarative pattern:\n\n```swift\nlet query = QueryCommand(\n    appIdentifier: \"com.apple.Safari\",\n    locator: AXLocator(criteria: [\n        AXCriterion(attribute: \"AXRole\", value: \"AXButton\"),\n        AXCriterion(attribute: \"AXTitle\", value: \"Back\")\n    ])\n)\n```\n\n## Proposed API for Shade\n```swift\n// Instead of manual tree walking:\nlet element = try await ax.findElement(\n    in: \"com.brave.Browser\",\n    matching: [\n        .role(.textField),\n        .identifier(\"url\", matching: .contains)\n    ]\n)\n\n// With fuzzy matching options:\nenum MatchType {\n    case exact\n    case contains      // case-insensitive substring\n    case regex\n    case prefix\n    case suffix\n}\n```\n\n## Benefits\n- More readable code\n- Easier to express complex queries\n- Better for debugging (can log the query)\n- Matches how AI agents think about UI elements\n\n## Implementation Notes\n- Could wrap our existing AccessibilityHelper\n- Add ElementSearch class with visitor pattern\n- Support early termination on first match\n- Consider depth limits for performance\n\n## References\n- https://github.com/steipete/AXorcist\n- Their ElementSearch and AXElementMatcher classes\n","status":"open","priority":4,"issue_type":"task","created_at":"2026-01-08T11:31:21.344817-05:00","created_by":"seth","updated_at":"2026-01-08T11:31:21.344817-05:00","dependencies":[{"issue_id":"shade-qji.7","depends_on_id":"shade-qji","type":"parent-child","created_at":"2026-01-08T11:31:21.345654-05:00","created_by":"seth"}]}
{"id":"shade-s7p","title":"Shift key combinations not passed to terminal/PTY","description":"## Bug Description\n\nShift key combinations fail in Shade's embedded terminal:\n- Cannot type `:` (Shift+;) to enter nvim command mode\n- Cannot type `O` (Shift+o) for new line above\n- All shifted characters appear to fail (?, \", {, etc.)\n\n## Works correctly in:\n- Regular nvim in Ghostty\n- Regular nvim in Kitty\n- Previously worked when Shade used Kitty as the terminal backend\n\n## Likely Cause\n\nShade's key event handling is not properly passing the Shift modifier to the PTY/terminal emulator. The issue is likely in how NSEvent key events are translated and written to the PTY.\n\n## Investigation Areas\n\n1. **Key event handling** - Check how `keyDown` events are processed\n   - Look for NSEvent handling in view controllers or custom views\n   - Check if `event.modifierFlags` includes `.shift` and if it's being used\n\n2. **Character translation** - The shifted character should come from `event.characters`, not manual shift handling\n   - `event.characters` = the actual typed character (already shift-aware)\n   - `event.charactersIgnoringModifiers` = the base key\n\n3. **PTY write path** - Verify the correct characters are being written to the PTY fd\n   - Add debug logging to see what bytes are actually sent\n\n4. **SwiftTerm or terminal emulator** - If using a library, check its key handling\n\n## Files to Investigate\n\n- Any `*ViewController.swift` or `*View.swift` with `keyDown` overrides\n- Terminal/PTY setup code\n- Any custom `NSTextInputClient` implementations\n\n## Test Case\n\n1. Launch Shade\n2. Open nvim (or just a shell)\n3. Try typing `:` - should fail (types `;` instead or nothing)\n4. Try typing `O` - should fail (types `o` instead or nothing)\n5. Try typing `?` - should fail","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-07T16:08:58.073974-05:00","created_by":"seth","updated_at":"2026-01-07T16:30:05.7797-05:00","closed_at":"2026-01-07T16:30:05.7797-05:00","close_reason":"Closed"}
