import Foundation

/// Configuration for Shade, loaded from ~/.config/shade/config.json
/// Config file is generated by Nix from dotfiles
struct ShadeConfig: Codable {
    var llm: LLMConfig?
    var capture: CaptureConfig?
    var window: WindowConfig?
    var notes: NotesConfig?

    /// Load config from XDG config directory
    /// Returns default config if file doesn't exist
    static func load() -> ShadeConfig {
        let configPath = ConfigDirectory.configFile

        guard FileManager.default.fileExists(atPath: configPath.path) else {
            Log.debug("No config file found at \(configPath.path), using defaults")
            return ShadeConfig()
        }

        do {
            let data = try Data(contentsOf: configPath)
            let config = try JSONDecoder().decode(ShadeConfig.self, from: data)
            Log.debug("Loaded config from \(configPath.path)")
            return config
        } catch {
            Log.error("Failed to load config: \(error), using defaults")
            return ShadeConfig()
        }
    }

    /// Merge CLI arguments over config file values
    /// CLI args take precedence
    func merging(cliArgs: CLIArguments) -> ShadeConfig {
        var merged = self

        // LLM overrides
        if cliArgs.noLLM {
            merged.llm?.enabled = false
        }
        if let backend = cliArgs.llmBackend {
            merged.llm = merged.llm ?? LLMConfig()
            merged.llm?.backend = backend
        }
        if let model = cliArgs.llmModel {
            merged.llm = merged.llm ?? LLMConfig()
            merged.llm?.model = model
        }

        return merged
    }
}

// MARK: - LLM Configuration

/// Configuration for MLX Swift LLM inference
struct LLMConfig: Codable {
    /// Whether LLM features are enabled
    var enabled: Bool = true

    /// Backend to use: "mlx" (default), future: "ollama", "openai"
    var backend: String = "mlx"

    /// Model identifier (Hugging Face format)
    /// Default: mlx-community/Qwen3-8B-Instruct-4bit (quality-focused)
    var model: String = "mlx-community/Qwen3-8B-Instruct-4bit"

    /// Preset: "quality", "balanced", "fast"
    var preset: String = "quality"

    /// Maximum tokens to generate
    var maxTokens: Int = 512

    /// Temperature for generation (0.0 = deterministic, 1.0 = creative)
    var temperature: Double = 0.7

    /// Top-p nucleus sampling
    var topP: Double = 0.9

    /// Idle timeout in seconds before unloading model (0 = never unload)
    var idleTimeout: Int = 300

    enum CodingKeys: String, CodingKey {
        case enabled
        case backend
        case model
        case preset
        case maxTokens = "max_tokens"
        case temperature
        case topP = "top_p"
        case idleTimeout = "idle_timeout"
    }
}

// MARK: - Capture Configuration

/// Configuration for note capture behavior
struct CaptureConfig: Codable {
    /// Working directory for captures (defaults to $notes_home/captures)
    var workingDirectory: String?

    /// Enable async enrichment (LLM processes after initial save)
    var asyncEnrichment: Bool = true

    /// Placeholder format for async content
    var placeholderPrefix: String = "<!-- shade:pending:"
    var placeholderSuffix: String = " -->"

    enum CodingKeys: String, CodingKey {
        case workingDirectory = "working_directory"
        case asyncEnrichment = "async_enrichment"
        case placeholderPrefix = "placeholder_prefix"
        case placeholderSuffix = "placeholder_suffix"
    }

    /// Get working directory, falling back to environment variable
    func resolvedWorkingDirectory() -> String {
        if let dir = workingDirectory, !dir.isEmpty {
            return dir
        }
        // Fall back to notes_home environment variable
        if let notesHome = ProcessInfo.processInfo.environment["notes_home"] {
            return "\(notesHome)/captures"
        }
        // Ultimate fallback
        let home = FileManager.default.homeDirectoryForCurrentUser.path
        return "\(home)/notes/captures"
    }

    /// Format a placeholder tag
    func placeholder(for type: String) -> String {
        return "\(placeholderPrefix)\(type)\(placeholderSuffix)"
    }
}

// MARK: - Window Configuration

/// Configuration for Shade panel window
struct WindowConfig: Codable {
    /// Panel width as percentage of screen (0.0-1.0)
    var widthPercent: Double = 0.4

    /// Panel height as percentage of screen (0.0-1.0)
    var heightPercent: Double = 0.6

    /// Position: "center", "right", "left"
    var position: String = "center"

    enum CodingKeys: String, CodingKey {
        case widthPercent = "width_percent"
        case heightPercent = "height_percent"
        case position
    }
}

// MARK: - Notes Configuration

/// Configuration for notes vault paths
/// Shade uses these to copy images to assets and know vault structure
struct NotesConfig: Codable {
    /// Root of the notes vault (e.g., ~/notes or ~/iclouddrive/Documents/_notes)
    var home: String?

    /// Assets directory for images (defaults to {home}/assets)
    var assetsDir: String?

    /// Captures directory for capture notes (defaults to {home}/captures)
    var capturesDir: String?

    enum CodingKeys: String, CodingKey {
        case home
        case assetsDir = "assets_dir"
        case capturesDir = "captures_dir"
    }

    /// Resolve home path, checking environment and common locations
    func resolvedHome() -> String {
        if let home = home, !home.isEmpty {
            return (home as NSString).expandingTildeInPath
        }
        // Check NOTES_HOME environment variable
        if let notesHome = ProcessInfo.processInfo.environment["NOTES_HOME"] {
            return notesHome
        }
        // Fallback to common locations
        let userHome = FileManager.default.homeDirectoryForCurrentUser.path
        let iCloudPath = "\(userHome)/iclouddrive/Documents/_notes"
        if FileManager.default.fileExists(atPath: iCloudPath) {
            return iCloudPath
        }
        return "\(userHome)/notes"
    }

    /// Resolve assets directory path
    func resolvedAssetsDir() -> String {
        if let assetsDir = assetsDir, !assetsDir.isEmpty {
            return (assetsDir as NSString).expandingTildeInPath
        }
        return "\(resolvedHome())/assets"
    }

    /// Resolve captures directory path
    func resolvedCapturesDir() -> String {
        if let capturesDir = capturesDir, !capturesDir.isEmpty {
            return (capturesDir as NSString).expandingTildeInPath
        }
        return "\(resolvedHome())/captures"
    }
}

// MARK: - CLI Arguments

/// Command-line argument overrides
struct CLIArguments {
    var noLLM: Bool = false
    var llmBackend: String?
    var llmModel: String?
}

// MARK: - Config Directory

/// XDG-compliant config directory management
enum ConfigDirectory {
    /// Config directory: ~/.config/shade/
    static var baseDir: URL {
        // Check XDG_CONFIG_HOME first
        if let xdgConfig = ProcessInfo.processInfo.environment["XDG_CONFIG_HOME"] {
            return URL(fileURLWithPath: xdgConfig).appendingPathComponent("shade")
        }
        let home = FileManager.default.homeDirectoryForCurrentUser
        return home.appendingPathComponent(".config/shade")
    }

    /// Main config file: ~/.config/shade/config.json
    static var configFile: URL {
        return baseDir.appendingPathComponent("config.json")
    }
}

// MARK: - Shared Instance

/// Global config instance, loaded once at startup
/// Use ShadeConfig.shared to access
extension ShadeConfig {
    private static var _shared: ShadeConfig?

    /// Shared config instance
    /// Loads from disk on first access
    static var shared: ShadeConfig {
        if _shared == nil {
            _shared = ShadeConfig.load()
        }
        return _shared!
    }

    /// Reload config from disk
    static func reload() {
        _shared = ShadeConfig.load()
        Log.debug("Reloaded config")
    }

    /// Update shared config with CLI args
    static func configure(with cliArgs: CLIArguments) {
        _shared = shared.merging(cliArgs: cliArgs)
        Log.debug("Applied CLI arguments to config")
    }
}
