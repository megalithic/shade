import AppKit
import Foundation

/// Configuration for Shade, loaded from ~/.config/shade/config.json
/// Config file is generated by Nix from dotfiles
struct ShadeConfig: Codable {
    var llm: LLMConfig?
    var capture: CaptureConfig?
    var window: WindowConfig?
    var notes: NotesConfig?

    /// Load config from XDG config directory
    /// Returns default config if file doesn't exist
    static func load() -> ShadeConfig {
        let configPath = ConfigDirectory.configFile

        guard FileManager.default.fileExists(atPath: configPath.path) else {
            Log.debug("No config file found at \(configPath.path), using defaults")
            return ShadeConfig()
        }

        do {
            let data = try Data(contentsOf: configPath)
            let config = try JSONDecoder().decode(ShadeConfig.self, from: data)
            Log.debug("Loaded config from \(configPath.path)")
            return config
        } catch {
            Log.error("Failed to load config: \(error), using defaults")
            return ShadeConfig()
        }
    }

    /// Merge CLI arguments over config file values
    /// CLI args take precedence
    func merging(cliArgs: CLIArguments) -> ShadeConfig {
        var merged = self

        // LLM overrides
        if cliArgs.noLLM {
            merged.llm?.enabled = false
        }
        if let backend = cliArgs.llmBackend {
            merged.llm = merged.llm ?? LLMConfig()
            merged.llm?.backend = backend
        }
        if let model = cliArgs.llmModel {
            merged.llm = merged.llm ?? LLMConfig()
            merged.llm?.model = model
        }

        return merged
    }
}

// MARK: - LLM Configuration

/// Configuration for MLX Swift LLM inference
struct LLMConfig: Codable {
    /// Whether LLM features are enabled
    var enabled: Bool = true

    /// Backend to use: "mlx" (default), future: "ollama", "openai"
    var backend: String = "mlx"

    /// Model identifier (Hugging Face format)
    /// Default: mlx-community/Qwen3-8B-Instruct-4bit (quality-focused)
    var model: String = "mlx-community/Qwen3-8B-Instruct-4bit"

    /// Preset: "quality", "balanced", "fast"
    var preset: String = "quality"

    /// Maximum tokens to generate
    var maxTokens: Int = 512

    /// Temperature for generation (0.0 = deterministic, 1.0 = creative)
    var temperature: Double = 0.7

    /// Top-p nucleus sampling
    var topP: Double = 0.9

    /// Idle timeout in seconds before unloading model (0 = never unload)
    var idleTimeout: Int = 300

    enum CodingKeys: String, CodingKey {
        case enabled
        case backend
        case model
        case preset
        case maxTokens = "max_tokens"
        case temperature
        case topP = "top_p"
        case idleTimeout = "idle_timeout"
    }
}

// MARK: - Capture Configuration

/// Configuration for note capture behavior
struct CaptureConfig: Codable {
    /// Working directory for captures (defaults to $notes_home/captures)
    var workingDirectory: String?

    /// Enable async enrichment (LLM processes after initial save)
    var asyncEnrichment: Bool = true

    /// Placeholder format for async content
    var placeholderPrefix: String = "<!-- shade:pending:"
    var placeholderSuffix: String = " -->"

    enum CodingKeys: String, CodingKey {
        case workingDirectory = "working_directory"
        case asyncEnrichment = "async_enrichment"
        case placeholderPrefix = "placeholder_prefix"
        case placeholderSuffix = "placeholder_suffix"
    }

    /// Get working directory, falling back to environment variable
    func resolvedWorkingDirectory() -> String {
        if let dir = workingDirectory, !dir.isEmpty {
            return dir
        }
        // Fall back to notes_home environment variable
        if let notesHome = ProcessInfo.processInfo.environment["notes_home"] {
            return "\(notesHome)/captures"
        }
        // Ultimate fallback
        let home = FileManager.default.homeDirectoryForCurrentUser.path
        return "\(home)/notes/captures"
    }

    /// Format a placeholder tag
    func placeholder(for type: String) -> String {
        return "\(placeholderPrefix)\(type)\(placeholderSuffix)"
    }
}

// MARK: - Window Configuration

/// Configuration for Shade panel window
struct WindowConfig: Codable {
    /// Panel width as percentage of screen (0.0-1.0)
    var widthPercent: Double = 0.4

    /// Panel height as percentage of screen (0.0-1.0)
    var heightPercent: Double = 0.6

    /// Position: "center", "right", "left"
    var position: String = "center"

    /// Focus border configuration
    var focusBorder: FocusBorderConfig?

    enum CodingKeys: String, CodingKey {
        case widthPercent = "width_percent"
        case heightPercent = "height_percent"
        case position
        case focusBorder = "focus_border"
    }
}

// MARK: - Focus Border Configuration

/// Configuration for the visual border shown when Shade panel has focus
struct FocusBorderConfig: Codable {
    /// Whether to show focus border
    var enabled: Bool = true

    /// Border width in points
    var width: Double = 2.0

    /// Border corner radius in points (0 = square corners)
    var cornerRadius: Double = 8.0

    /// Border color as hex string (e.g., "#83A598" for Everforest aqua)
    /// Supports formats: "#RGB", "#RRGGBB", "#RRGGBBAA"
    var color: String = "#83A598"

    /// Opacity of the border (0.0 - 1.0)
    var opacity: Double = 0.8

    /// Whether to animate the border appearance
    var animated: Bool = true

    /// Animation duration in seconds
    var animationDuration: Double = 0.15

    /// Menu bar icon stroke color when focused (hex string, e.g., "#E68C59" for Everforest orange)
    /// Applies to outline/stroke rendering of the ghost icon
    var menubarStrokeColor: String = "#E68C59"

    enum CodingKeys: String, CodingKey {
        case enabled
        case width
        case cornerRadius = "corner_radius"
        case color
        case opacity
        case animated
        case animationDuration = "animation_duration"
        case menubarStrokeColor = "menubar_stroke_color"
    }

    /// Parse hex color string to NSColor
    func parsedColor() -> NSColor {
        return Self.parseHexColor(color, opacity: opacity)
    }

    /// Parse menubar stroke color (full opacity by default)
    func parsedMenubarStrokeColor() -> NSColor {
        return Self.parseHexColor(menubarStrokeColor, opacity: 1.0)
    }

    /// Helper to parse hex color strings
    /// - Parameters:
    ///   - hexString: Color in #RGB, #RRGGBB, or #RRGGBBAA format
    ///   - opacity: Opacity multiplier (0.0-1.0)
    /// - Returns: Parsed NSColor or fallback color
    static func parseHexColor(_ hexString: String, opacity: Double) -> NSColor {
        var hex = hexString.trimmingCharacters(in: .whitespacesAndNewlines)
        if hex.hasPrefix("#") {
            hex.removeFirst()
        }

        var rgb: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&rgb)

        switch hex.count {
        case 3: // RGB
            let r = Double((rgb >> 8) & 0xF) / 15.0
            let g = Double((rgb >> 4) & 0xF) / 15.0
            let b = Double(rgb & 0xF) / 15.0
            return NSColor(red: r, green: g, blue: b, alpha: opacity)
        case 6: // RRGGBB
            let r = Double((rgb >> 16) & 0xFF) / 255.0
            let g = Double((rgb >> 8) & 0xFF) / 255.0
            let b = Double(rgb & 0xFF) / 255.0
            return NSColor(red: r, green: g, blue: b, alpha: opacity)
        case 8: // RRGGBBAA
            let r = Double((rgb >> 24) & 0xFF) / 255.0
            let g = Double((rgb >> 16) & 0xFF) / 255.0
            let b = Double((rgb >> 8) & 0xFF) / 255.0
            let a = Double(rgb & 0xFF) / 255.0
            return NSColor(red: r, green: g, blue: b, alpha: a * opacity)
        default:
            // Fallback to Everforest aqua
            return NSColor(red: 0.514, green: 0.647, blue: 0.596, alpha: opacity)
        }
    }
}

// MARK: - Notes Configuration

/// Configuration for notes vault paths
/// Shade uses these to copy images to assets and know vault structure
struct NotesConfig: Codable {
    /// Root of the notes vault (e.g., ~/notes or ~/iclouddrive/Documents/_notes)
    var home: String?

    /// Assets directory for images (defaults to {home}/assets)
    var assetsDir: String?

    /// Captures directory for capture notes (defaults to {home}/captures)
    var capturesDir: String?

    enum CodingKeys: String, CodingKey {
        case home
        case assetsDir = "assets_dir"
        case capturesDir = "captures_dir"
    }

    /// Resolve home path, checking environment and common locations
    func resolvedHome() -> String {
        if let home = home, !home.isEmpty {
            return (home as NSString).expandingTildeInPath
        }
        // Check NOTES_HOME environment variable
        if let notesHome = ProcessInfo.processInfo.environment["NOTES_HOME"] {
            return notesHome
        }
        // Fallback to common locations
        let userHome = FileManager.default.homeDirectoryForCurrentUser.path
        let iCloudPath = "\(userHome)/iclouddrive/Documents/_notes"
        if FileManager.default.fileExists(atPath: iCloudPath) {
            return iCloudPath
        }
        return "\(userHome)/notes"
    }

    /// Resolve assets directory path
    func resolvedAssetsDir() -> String {
        if let assetsDir = assetsDir, !assetsDir.isEmpty {
            return (assetsDir as NSString).expandingTildeInPath
        }
        return "\(resolvedHome())/assets"
    }

    /// Resolve captures directory path
    func resolvedCapturesDir() -> String {
        if let capturesDir = capturesDir, !capturesDir.isEmpty {
            return (capturesDir as NSString).expandingTildeInPath
        }
        return "\(resolvedHome())/captures"
    }
}

// MARK: - CLI Arguments

/// Command-line argument overrides
struct CLIArguments {
    var noLLM: Bool = false
    var llmBackend: String?
    var llmModel: String?
}

// MARK: - Config Directory

/// XDG-compliant config directory management
enum ConfigDirectory {
    /// Config directory: ~/.config/shade/
    static var baseDir: URL {
        // Check XDG_CONFIG_HOME first
        if let xdgConfig = ProcessInfo.processInfo.environment["XDG_CONFIG_HOME"] {
            return URL(fileURLWithPath: xdgConfig).appendingPathComponent("shade")
        }
        let home = FileManager.default.homeDirectoryForCurrentUser
        return home.appendingPathComponent(".config/shade")
    }

    /// Main config file: ~/.config/shade/config.json
    static var configFile: URL {
        return baseDir.appendingPathComponent("config.json")
    }
}

// MARK: - Shared Instance

/// Global config instance, loaded once at startup
/// Use ShadeConfig.shared to access
extension ShadeConfig {
    private static var _shared: ShadeConfig?

    /// Shared config instance
    /// Loads from disk on first access
    static var shared: ShadeConfig {
        if _shared == nil {
            _shared = ShadeConfig.load()
        }
        return _shared!
    }

    /// Reload config from disk
    static func reload() {
        _shared = ShadeConfig.load()
        Log.debug("Reloaded config")
    }

    /// Update shared config with CLI args
    static func configure(with cliArgs: CLIArguments) {
        _shared = shared.merging(cliArgs: cliArgs)
        Log.debug("Applied CLI arguments to config")
    }
}
